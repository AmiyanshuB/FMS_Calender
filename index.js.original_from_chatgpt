// server/index.js
const express = require('express');
const fs = require('fs');
const path = require('path');
const http = require('http');

const app = express();
app.use(express.json());

const server = http.createServer(app);
const io = require('socket.io')(server, {
  cors: {
    origin: '*',
    methods: ['GET','POST']
  }
});

// simple auth middleware example: checks Authorization: Bearer <token>
// In your real app, replace with your existing auth verification
function authMiddleware(req, res, next){
  // allow if no auth required for read
  const adminPaths = ['/api/schedule/update','/api/schedule/slot'];
  if (!adminPaths.includes(req.path)) return next();
  const auth = req.headers['authorization'] || '';
  const token = auth.replace('Bearer ','').trim();
  // very simple: token === "admin-token" => admin
  if(token === 'admin-token'){
    req.user = { userId: 'admin', isAdmin: true };
    return next();
  }
  return res.status(403).json({ error: 'forbidden' });
}

app.use(authMiddleware);

const DATA_DIR = path.join(__dirname, 'data');
const SCHEDULE_FILE = path.join(DATA_DIR, 'masterSchedule.json');

function readSchedule(){
  try{
    const raw = fs.readFileSync(SCHEDULE_FILE, 'utf8');
    return JSON.parse(raw);
  }catch(e){
    return [];
  }
}
function writeSchedule(obj){
  fs.writeFileSync(SCHEDULE_FILE, JSON.stringify(obj, null, 2), 'utf8');
}

// GET schedule
app.get('/api/schedule', (req, res) => {
  const schedule = readSchedule();
  res.json(schedule);
});

// POST update entire schedule (admin)
app.post('/api/schedule/update', (req, res) => {
  if(!req.user || !req.user.isAdmin) return res.status(403).json({ error: 'forbidden' });
  const payload = req.body;
  if(!Array.isArray(payload)) return res.status(400).json({ error: 'invalid payload, expected array' });
  // basic validation: each entry must have day, room, startTime, endTime, className
  const invalid = payload.find(it => !it.day || !it.room || !it.startTime || !it.endTime);
  if(invalid) return res.status(400).json({ error: 'invalid item in schedule' });
  try{
    writeSchedule(payload);
    // broadcast via socket
    io.emit('schedule:update', payload);
    return res.json({ success: true, schedule: payload });
  }catch(e){
    console.error('write error', e);
    return res.status(500).json({ error: 'write failed' });
  }
});

// POST update a single slot (admin) - merge logic: add or replace overlapping slot
app.post('/api/schedule/slot', (req, res) => {
  if(!req.user || !req.user.isAdmin) return res.status(403).json({ error: 'forbidden' });
  const { day, room, startTime, endTime, className } = req.body;
  if(!day || !room || !startTime || !endTime) return res.status(400).json({ error: 'missing fields' });
  const schedule = readSchedule();
  // remove entries that overlap same room/day/time range
  const sParts = startTime.split(':').map(Number);
  const eParts = endTime.split(':').map(Number);
  const sMin = sParts[0]*60 + (sParts[1]||0);
  const eMin = eParts[0]*60 + (eParts[1]||0);
  const filtered = schedule.filter(it => {
    if(it.day !== day || it.room !== room) return true;
    const itS = it.startTime.split(':').map(Number); const itE = it.endTime.split(':').map(Number);
    const itSmin = itS[0]*60 + (itS[1]||0); const itEmin = itE[0]*60 + (itE[1]||0);
    // if overlapping -> remove
    if(!(eMin <= itSmin || sMin >= itEmin)) return false;
    return true;
  });
  filtered.push({ day, room, startTime, endTime, className });
  try{
    writeSchedule(filtered);
    io.emit('schedule:update', filtered);
    return res.json({ success: true, schedule: filtered });
  }catch(e){
    return res.status(500).json({ error: 'write failed' });
  }
});

// serve static if needed
app.use(express.static(path.join(__dirname, '..', 'public')));

// socket connection
io.on('connection', (socket) => {
  console.log('socket connected', socket.id);
  // optionally send current schedule to client immediately
  socket.on('request:schedule', () => {
    try{
      const s = readSchedule();
      socket.emit('schedule:update', s);
    }catch(e){}
  });
});

// start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log('Server listening on', PORT);
});